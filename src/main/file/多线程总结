## 线程的安全机制


#### 锁的相关概念：
1. 公平锁：多个现成按照申请锁的顺序去获取锁，现成会直接进入队列中排队，永远都是队列第一位才能获取锁。
   *优点：所有的线程都能得到资源，不会饿死在队列中。
   *缺点: 因为cpu需要一次唤醒阻塞队线程，开销会很大，影响吞吐量。
2. 非公平锁：多个线程去获取锁的时候，会直接去获取锁，如果获取不到，会进入等待队列。
   *优点: 相对于公平锁来说，cpu不必唤醒所有的线程，减少了cpu的开销，整体的吞吐量效率会高一点。
   *缺点: 会造成线程的饥饿，队列中的某个线程会长时间获取不到锁。
3. 可重入锁：一个线程如果持有锁，那么它可以再次进入线程获取锁的时候，不需要等待。不会因为之前获取过锁没有释放而造成死锁。
### 使用synchronized
**synchronized的锁定范围**
1. 对象锁
    指多个线程调用同一对象的同步方法会阻塞 ，调用不同对象的同步方法不会阻塞
    - 修饰在普通方法上
    - 修饰在代码块，括号后面是类对象
2. 类锁
    指多个线程调用时候，不管是不是同一对象，都会被阻塞。
    - 修饰在静态方法上
    - 修饰在代码块，括号后面是类的class对象

### 使用显示锁
### 使用volatile
### 使用原子变量和cas
### 写时复制
### 使用threadLocal

## 线程的协作机制
### wait/notify
### 显示条件
### 线程的中断
### 协作工具类
### 阻塞队列
### future/ futureTask

## 容器类
### 写时复制的list和set
### concurrentHashMap
### 各种队列


## 任务执行服务
### 线程池
#### 线程的创建
1. 继承thread
2. 实现runnable接口
#### 线程的状态变化

### 定时任务

