## 线程的安全机制

#### 锁的相关概念：
1. 公平锁：多个现成按照申请锁的顺序去获取锁，现成会直接进入队列中排队，永远都是队列第一位才能获取锁。
   *优点：所有的线程都能得到资源，不会饿死在队列中。
   *缺点: 因为cpu需要一次唤醒阻塞队线程，开销会很大，影响吞吐量。
2. 非公平锁：多个线程去获取锁的时候，会直接去获取锁，如果获取不到，会进入等待队列。
   *优点: 相对于公平锁来说，cpu不必唤醒所有的线程，减少了cpu的开销，整体的吞吐量效率会高一点。
   *缺点: 会造成线程的饥饿，队列中的某个线程会长时间获取不到锁。
3. 可重入锁：一个线程如果持有锁，那么它可以再次进入线程获取锁的时候，不需要等待。不会因为之前获取过锁没有释放而造成死锁。
### 使用synchronized
**synchronized的锁定范围**
1. 对象锁
    指多个线程调用同一对象的同步方法会阻塞 ，调用不同对象的同步方法不会阻塞
    - 修饰在普通方法上
    - 修饰在代码块，括号后面是类对象
2. 类锁
    指多个线程调用时候，不管是不是同一对象，都会被阻塞。
    - 修饰在静态方法上
    - 修饰在代码块，括号后面是类的class对象

**synchronized版本对比**
- 1.6之前，synchronized是重量级锁，是基于底层的mutex lock实现的，每次获取锁，释放锁都会带来**上下文切换(用户态和内核态的切换)**，从而增加了系统性能的开销，在锁竞争激烈的时候性能会非常差。
- 1.6以后，synchronized锁进行了优化，引入了偏向锁，轻量级锁，最后升级为重量级锁。通过竞争的激烈程度来自动选择合适的锁，通过java对象头存储锁的信息，避免一开始就使用重量级锁，以及减少锁竞争带来的上下文切换，从而提高性能。

**synchronized底层原理**
- synchronized如果修饰的是代码块则会插入字节码指令**monitor enter**和**monitor exit**，一般会生成这两个monitor指令会自动解锁，因为有异常情况也需要解锁，不然就会死锁的。
synchronized深入到jvm底层是和对象头息息相关的。
#### 对象的组成
*1. 对象头*
- markWord 标记字段 : 存储哈希码，对象年龄，锁信息（锁标志位，偏向线程id，偏向时间戳等)。 不同的对象头中markWord的存储结构是不同的。
- klass pointer 类型指针：当前对象类的元数据指针，虚拟机通过这个指针来指定这个对象是那个类的实例。（klass：jvm中的数据结构，存储类的信息包括常量池，字段，方法等。存放在方法区）
- 数组长度： 只有数组对象才有
*2. 实例数据*
- 程序代码里面所定义的各种类型的字段内容，包括从父类继承下来的。
*3. 对象填充*
- 仅仅起到占位符的作用，若对象实例数据没有对齐的话，会通过对其填充来补全。

#### 对象头详细
![avatar](pic/32.png)

![avatar](pic/64.png)

#### 锁状态
![avatar](pic/锁状态.png)

####1.无锁
- 对象头的25bit用来存储对象的hashCode；4bit用来存储对象的分代年龄；1bit存储是否偏向锁的锁标识位，当前为否；2bit用来存放锁标识位01。
####2.偏向锁
- 对象头的25bit分为两段，23bit用来存线程id，2bit用来存epoch；4bit用来存对象的分代年龄；1bit存储偏向锁的锁表示为，当前位是；2bit用来存放锁表示位01。
> 为什么有偏向锁
* 在实际的生产环境中，一段时间内同步的方法会被同一个线程访问。如果使用轻量级锁，每次调用同步方法，都要通过一次cas来申请锁，通过一次cas来释放锁。
这种cas毕竟会占用cpu的资源（cas指的是轻量锁使用cas将markWord更新为指向锁记录的指针，所以针对此场景进行了优化，当线程A调用同步方法的指向后，不会释放锁，
再次进入的时候，不需要重新获取锁。只有在其他线程的进入的时候，才会重新获取。
> 偏向锁原理
* 如果当前对象支持偏向锁，就会通过cas操作，将当前的线程地址记录到*markWord*中，并且标记字段的后三位设置为*101*。
之后如果有线程来请求这把锁，只需要判断*markWord*最后的三位是不是101，以及是否指向当前的线程地址。同时还需要判断*epoch*值是否和锁对象中的*epoch*一致。如果都一致，说明当前线程持有偏向锁。

>线程已经偏向某个线程必须满足的条件
> *markWord中的threadId是线程的ID。
> *markWord中的epoch必须和类的epoch相等。

* 如果下一个线程要获取锁的时候，发现对象是可偏向的，但是偏向的线程id和当前获取的现成id不同，说明这个偏向锁偏向于其他线程，需要撤销偏向锁模式。*（注意这里是撤销，不是解锁，因为现在需要将偏向锁的模式进行膨胀）*
>偏向锁的撤销
* 偏向锁的撤销是一个很特殊的操作，为了执行撤销的操作，需要等待全局安全点（safe point），此时间点所有的工作线程都停止了字节码的执行。在进入膨胀流程的时候，会判断偏向锁的现成是否正在执行同步代码块，
如果持有偏向锁的线程已经执行完了，就应该将偏向锁对象的mark work置为无锁的状态。但是，如果还没有执行完，应该直接将偏向锁膨胀为轻量锁。后面就是走轻量锁的逻辑了。

>为什么要等待全局安全点时候才能进行膨胀？
* 首先这个时间点所有的工作线程都停止了字节码的执行。其次就是线程A在占用偏向锁执行同步代码块的时候，线程B也要抢占偏向锁，证明存在多线程竞争，线程B就需要将这个偏向锁进行膨胀，这也就意味这个线程B需要操作线程A的线程栈。
所以需要找一个等待的时间点，让线程B来操作，这个时间点就是*stop the world*，没有字节码执行的时候。

### 使用显示锁
### 使用volatile
### 使用原子变量和cas
### 写时复制
### 使用threadLocal

## 线程的协作机制
### wait/notify
### 显示条件
### 线程的中断
### 协作工具类
### 阻塞队列
### future/ futureTask

## 容器类
### 写时复制的list和set
### concurrentHashMap
### 各种队列


## 任务执行服务
### 线程池
#### 线程的创建
1. 继承thread
2. 实现runnable接口
#### 线程的状态变化

### 定时任务

